package starling.geom{   import flash.geom.Point;   import flash.utils.getQualifiedClassName;   import starling.utils.VectorUtil;   import starling.utils.VertexData;      public class Polygon   {            private static var sRestIndices:Vector.<uint> = new Vector.<uint>(0);                   private var mCoords:Vector.<Number>;            public function Polygon(vertices:Array = null) { super(); }            public static function createEllipse(x:Number, y:Number, radiusX:Number, radiusY:Number) : Polygon { return null; }            public static function createCircle(x:Number, y:Number, radius:Number) : Polygon { return null; }            public static function createRectangle(x:Number, y:Number, width:Number, height:Number) : Polygon { return null; }            [Inline]      private static function isConvexTriangle(ax:Number, ay:Number, bx:Number, by:Number, cx:Number, cy:Number) : Boolean { return false; }            private static function isPointInTriangle(px:Number, py:Number, ax:Number, ay:Number, bx:Number, by:Number, cx:Number, cy:Number) : Boolean { return false; }            private static function areVectorsIntersecting(ax:Number, ay:Number, bx:Number, by:Number, cx:Number, cy:Number, dx:Number, dy:Number) : Boolean { return false; }            public function clone() : Polygon { return null; }            public function reverse() : void { }            public function addVertices(... args) : void { }            public function setVertex(index:int, x:Number, y:Number) : void { }            public function getVertex(index:int, result:Point = null) : Point { return null; }            public function contains(x:Number, y:Number) : Boolean { return false; }            public function containsPoint(point:Point) : Boolean { return false; }            public function triangulate(result:Vector.<uint> = null) : Vector.<uint> { return null; }            public function copyToVertexData(target:VertexData, targetIndex:int = 0) : void { }            public function copyToVector(target:Vector.<Number>, targetIndex:int = 0, stride:int = 0) : void { }            public function toString() : String { return null; }            public function get isSimple() : Boolean { return false; }            public function get isConvex() : Boolean { return false; }            public function get area() : Number { return 0; }            public function get numVertices() : int { return 0; }            public function set numVertices(value:int) : void { }   }}import flash.errors.IllegalOperationError;import flash.utils.getQualifiedClassName;import starling.geom.Polygon;class ImmutablePolygon extends Polygon{          private var mFrozen:Boolean;      function ImmutablePolygon(vertices:Array) { super(null); }      override public function addVertices(... args) : void { }      override public function setVertex(index:int, x:Number, y:Number) : void { }      override public function reverse() : void { }      override public function set numVertices(value:int) : void { }      private function getImmutableError() : Error { return null; }}class Ellipse extends ImmutablePolygon{          private var mX:Number;      private var mY:Number;      private var mRadiusX:Number;      private var mRadiusY:Number;      function Ellipse(x:Number, y:Number, radiusX:Number, radiusY:Number, numSides:int = -1) { super(null); }      private function getVertices(numSides:int) : Array { return null; }      override public function triangulate(result:Vector.<uint> = null) : Vector.<uint> { return null; }      override public function contains(x:Number, y:Number) : Boolean { return false; }      override public function get area() : Number { return 0; }      override public function get isSimple() : Boolean { return false; }      override public function get isConvex() : Boolean { return false; }}class Rectangle extends ImmutablePolygon{          private var mX:Number;      private var mY:Number;      private var mWidth:Number;      private var mHeight:Number;      function Rectangle(x:Number, y:Number, width:Number, height:Number) { super(null); }      override public function triangulate(result:Vector.<uint> = null) : Vector.<uint> { return null; }      override public function contains(x:Number, y:Number) : Boolean { return false; }      override public function get area() : Number { return 0; }      override public function get isSimple() : Boolean { return false; }      override public function get isConvex() : Boolean { return false; }}